---
title: 5 网络包（使用T88）
description: 网络包（使用T88）
hide_table_of_contents: false
sidebar_position: 150
---

# 网络包

与其他教程可能略有不同的是，我们将会使用T88的网络包注解系统来完成这一部分。

:::info

如果你更喜欢使用纯原版内容来编写网络包，[Fledge的Boson教程](https://boson.v2mcdev.com/networking/custompack.html)是一个非常不错的选择。不过你需要注意其中使用的是mcp表。

:::

---

## 准备工作

:::info

你可以先阅读`-5 lib-mod`的`使用这个lib-mod`部分，了解更多关于添加依赖的知识。

:::

首先你需要在[T88的CurseForge文件页面](https://www.curseforge.com/minecraft/mc-mods/t88/files)找到右侧的项目编号`Project ID`，它应该始终是`663112`。然后在文件列表中找到最新的**不带**`source`字样的jar，将鼠标置于其上，在浏览器的下方便会显示出这个jar文件的链接，链接的最后是它的编号，记下它。

:::note

对于正在写这篇教程的我，现在是2022年1月17日，此时最新版本的T88是0.2.14，它对应的`t88-0.2.14.jar`编号是`4346957`，没有对应的`source`jar。

如果你阅读了`lib-mod`一节，你就会知道在有**相同版本号**的带`source`字样的jar时，如何将它也加入你的依赖之中。

:::

打开你项目的`build.gradle`，添加

```gradle {2-7,15-16}
repositories {
    maven {
        url "https://cursemaven.com"
        content {
            includeGroup "curse.maven"
        }
    }
}

dependencies {
    minecraft 'net.minecraftforge:forge:1.18.2-40.1.86'
    
    annotationProcessor 'org.spongepowered:mixin:0.8.5:processor'
    
	implementation fg.deobf('curse.maven:t88-663112:4346957')
    annotationProcessor 'curse.maven:t88-663112:4346957'
}
```

刷新gradle项目，你应该就能在`外部库`中找到T88了。

## 编写网络包

在R6MS中，当玩家点击加入或退出排队时，我们需要发包告知服务器这个变化；当服务器由于某种原因将玩家踢出队列时，客户端也需要及时地知道这个变化。

这是我们的`PlayerQueuePack`类，它负责完成上述的工作：

```java
@NetPacket(packetName = "r6ms:player_queue")
public class PlayerQueuePack extends AbstractNetworkPacket {
    String event;

    public PlayerQueuePack(String event) {
        this.event = event;
    }

    @Decoder
    public PlayerQueuePack(FriendlyByteBuf buf) {
        this.event = buf.readUtf();
    }

    @Encoder
    public void writeToNet(FriendlyByteBuf buf) {
        buf.writeUtf(event);
    }

    @Consumer
    public void handler(Supplier<NetworkEvent.Context> context) {
        context.get().enqueueWork(
                () -> {
                    if (context.get().getDirection().equals(NetworkDirection.PLAY_TO_SERVER)) {
                        serverHandler();
                    } else {
                        clientHandler();
                    }
                }
        );
        context.get().setPacketHandled(true);
    }

    public void serverHandler() {
        switch (event){
            case "joinQueue":
                ...
    }

    public void clientHandler() {
	...
    }
}
```

所有的新网络包都应该继承`AbstractNetworkPacket`，它提供一些普遍需要的字段和方法。

注解`@NetPacket`标记了这个类需要在编译时由T88对其生成对应的注册内容。你需要手动填写`packetName`一项，它是你发送这个网络包所需的`SimpleChannel`的名称。你应该按一般`ResourceLocation`的参数格式来填写它，即`"[modID]:[网络包名称]"`。

随后，你所有需要传输的内容都应该写在成员变量中，在这里我们只需要一个字符串就足够了。接下来是一个简单的构造方法，我们在其他代码中创建包时会用到。

一个网络包还需要三个关键的方法，分别用于把一串字节解码组装成包、把网络包里面的内容打包成一串字节，以及在收到网络包之后执行的动作。他们对应需要的注解分别是`@Decoder`、`@Encoder`和`@Consumer`，不需要任何额外的参数。

很明显，`FriendlyByteBuf`提供分别地提供了对应的读写方法，我们只需要简单调用即可。稍加探索你就会发现，它提供的可以编/解码的对象十分多样。

最后一个就是负责最终执行的方法了。上面展示的是一个常见的写法，将服务器收到客户端发来的包时需要做的写在`serverHandler()`里，将客户端收到服务器发来的包时需要做的写在`clientHandler()`里。如果你的包只是单向发送，或许你就可以都写在一个方法里面。

:::tip

所有需要进行的动作都需要写在`context.get().enqueueWork()`里：负责收发网络包的显然不是主线程，你也不能在收到网络包后立即对主线程进行操作。

参数`context`值得一探，其中含有许多对你有用的方法。

:::

## 发送网络包

由于服务器和客户端是一对多的关系，从客户端向服务器发包十分简单：

```java
PlayerQueuePack.CHANNEL.sendToServer(new PlayerQueuePack("joinQueue"));
```

而从服务器向客户端发包则略复杂一些。假设我们已经通过某种途径获得了一个ServerPlayer对象，想要向他发包：

```java
PlayerQueuePack.CHANNEL.send(PacketDistributor.PLAYER.with(() -> serverPlayer), new PlayerQueuePack("kick"));
```



## 奇奇怪怪的注意事项

### 一些特殊类的编解码



### 服务器安全问题

